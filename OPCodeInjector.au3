#cs ----------------------------------------------------------------------------

 AutoIt Version: 3.3.8.1
 Author: Naker90

 Script Function:
	Opcodes Remote Injection Process

 Los OpCodes que estan en el ejemplo inyectan un mensaje en el proceso

 Testeado en W7 x64 bits

 Ejemplo de uso:
 _OpcodesRemoteInjectionProcess('Anotador Naker90.exe') => Inyecta los opcodes en el proceso Anotador Naker90.exe

#ce ----------------------------------------------------------------------------

Func _OpcodesRemoteInjectionProcess($sProcessName)

	;Constantes necesarias para las llamadas a las APIS
	Const $sProcessAccessRight = 0x1F0FFF
	Const $sVirtualAlocRight = 0x00001000
	Const $sPAGE_EXECUTE_READWRITE = 0x40

	;OPCODES
	Local $sOpCodes = "0xFC33D2B23064FF325A8B520C8B52148B722833C9B11833FF33C0AC3C617C022C20C1CF0D03F8E2F081FF5BBC4A6A8B5A108B1275DA8B533C03D3FF72348B527803D38B722003F333C941AD03C381384765745075F4" & _
			"817804726F634175EB8178086464726575E2498B722403F3668B0C4E8B721C03F38B148E03D35233FF576861727941684C696272684C6F61645453FFD2683332010166897C2402687573657254FFD0686F7841018BDF885C24036861676542684D6573735450FF54" & _
			"242C57685E2E5E218BDC57535357FFD068657373018BDF885C24036850726F63684578697454FF742440FF54244057FFD0C3"

	;Creamos la estructura para los OpCodes y la escribimos
	Local $sOPCodeStrut = DllStructCreate('Byte[' & BinaryLen($sOpCodes) & ']')
	DllStructSetData($sOPCodeStrut, 1, $sOpCodes)

	;Obtenemos el peso de la estructura
	Local $sSize = DllStructGetSize($sOPCodeStrut)

	;Obtenemos el PID del proceso a inyectar
	Local $sPID = ProcessExists($sProcessName)

	;Si el PID es 0 lanzamos un error y salimos
	If $sPID = 0 Then
		MsgBox(16, 'ERROR', '¡El proceso no se encuentra en ejecución!')
		Exit
	EndIf

	;Abrimos el proceso con OpenProcess
	Local $sOpenProcess = DllCall('Kernel32.dll', 'Handle', 'OpenProcess', 'Dword', $sProcessAccessRight, 'Bool', False, 'Dword', $sPID)
	If Not ($sOpenProcess[0]) Then
		MsgBox(16, 'ERROR', 'Hubo un error abriendo el proceso con OpenProcess!')
		Exit
	EndIf

	;Reservamos memoria para la estructura con VirtualAllocEX y la escribimos con WriteProcessMemory
	Local $sVirtualAloc = DllCall('Kernel32.dll', 'Ptr', 'VirtualAllocEx', 'Handle', $sOpenProcess[0], 'Ptr', 0, 'Ulong_Ptr', $sSize, 'Dword', $sVirtualAlocRight, 'Dword', $sPAGE_EXECUTE_READWRITE)
	If Not ($sVirtualAloc[0]) Then
		MsgBox(16, 'ERROR', 'Hubo un error reservando memoria para la estructura!')
		Exit
	EndIf
	Local $sWriteStruct = DllCall('Kernel32.dll', 'Int', 'WriteProcessMemory', 'Handle', $sOpenProcess[0], 'Ptr', $sVirtualAloc[0], 'Ptr', DllStructGetPtr($sOPCodeStrut), 'ULong_Ptr', $sSize, 'Ulong_Ptr', 0)
	If $sWriteStruct = 0 Then
		MsgBox(16, 'ERROR', 'Hubo un error escribiendo la estructura en memoria!')
		Exit
	EndIf

	;Lanzamos el hilo remoto con CreateRemoteThread y esperamos con un WaitSingleObject
	Local $sRemoteThread = DllCall('Kernel32.dll', 'Handle', 'CreateRemoteThread', 'Handle', $sOpenProcess[0], 'Ptr', 0, 'Ulong_Ptr', 0, 'Ptr', $sVirtualAloc[0], 'Ptr', 0, 'Dword', 0, 'Dword', 0)
	If Not ($sRemoteThread[0]) Then
		MsgBox(16, 'ERROR', 'Hubo un error lanzando el hilo!')
		Exit
	EndIf
	Local $sWait = DllCall('Kernel32.dll', 'ptr', 'WaitForSingleObject', 'handle', $sRemoteThread[0], 'dword', 0x7FFFFFFF)

	;Cerramos el handle del OpenProcess
	Local $sCloseOpen = DllCall('Kernel32.dll', 'Int', 'CloseHandle', 'Handle', $sOpenProcess[0])
	If $sCloseOpen = 0 Then
		MsgBox(16, 'ERROR', 'Hubo un error cerrando el handle del proceso!')
		Exit
	EndIf

EndFunc   ;==>_OpcodesRemoteInjectionProcess
