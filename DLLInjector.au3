#cs ----------------------------------------------------------------------------

	AutoIt Version: 3.3.8.1
	Author: Naker90

	Script Function:
	Inyecta una DLL en un proceso en ejecucion

	Testeado en W7 x32 y x64

	Agradecimientos a M3 & Pink

	Ejemplo de uso:
	InjectDLL('C:\Users\Naker90\Desktop\Mensaje.dll', 'calc.exe')

#ce ----------------------------------------------------------------------------

Func InjectDLL($sDLLPath, $sProcess)

	Const $PROCESS_ALL_ACCESS = 0x1F0FFF
	Const $MEM_RESERVE = 0x00001000
	Const $PAGE_READWRITE = 0x40

	;Obtenemos el PID del proceso a injectar
	Local $sProcessID = ProcessExists($sProcess)

	;Si el PID es 0, ejecutamos el proceso y obtenemos el PID de este
	If $sProcessID = 0 Then
		ShellExecute($sProcess)
		;Damos tiempo para que se abra el proceso, si no se da el tiempo de espera el proceso se cuelga
		Sleep(500)
		$sProcessID = ProcessExists($sProcess)
	EndIf

	;Abrimos el objeto del proceso existente
	Local $sOpen = DllCall('Kernel32.dll', 'handle', 'OpenProcess', 'dword', $PROCESS_ALL_ACCESS, 'bool', False, 'dword', $sProcessID)
	;depuramos para saber si existe algun error
	If Not ($sOpen[0]) Then
		MsgBox(64, 'ERROR', 'Hubo un error abriendo el proceso ' & $sProcess)
	EndIf

	;Reservamos memoria en el objeto del proceso que abrimos anteriormente
	Local $sStruct = DllStructCreate('byte[' & BinaryLen($sDLLPath) & ']')
	Local $sMemory = DllCall('Kernel32.dll', 'handle', 'VirtualAllocEx', 'handle', $sOpen[0], 'ptr', 0, 'ULONG_PTR', DllStructGetSize($sStruct), 'dword', $MEM_RESERVE, 'dword', $PAGE_READWRITE)
	;depuramos para saber si existe algun error
	If Not ($sMemory[0]) Then
		MsgBox(64, '', 'Hubo un error reservando memoria')
	EndIf

	;Escribimos en el espacio de memoria obtenido anteriormente la ruta de la DLL
	Local $sWriteMemory = DllCall('Kernel32.dll', 'int', 'WriteProcessMemory', 'handle', $sOpen[0], 'ptr', $sMemory[0], 'str', $sDLLPath, 'ULONG_PTR', DllStructGetSize($sStruct), 'ULONG_PTR', 0)
	;depuramos para saber si existe algun error
	If Not ($sWriteMemory[0]) Then
		MsgBox(64, '', 'Hubo un error en la escritura en memoria')
	EndIf

	;Obtenemos la direccion de LoadLibrary, para ello utilizamos GetProcAdress.
	Local $sGetModuleHandle = DllCall('Kernel32.dll', 'handle', 'GetModuleHandleA', 'str', 'Kernel32.dll')
	Local $sGetProcAdress = DllCall('Kernel32.dll', 'handle', 'GetProcAddress', 'dword', $sGetModuleHandle[0], 'str', 'LoadLibraryA')
	;depuramos para saber si existe algun error
	If Not ($sGetProcAdress[0]) Then
		MsgBox(64, '', 'Hubo un error obteniendo la direccion de LoadLibrary')
	EndIf

	;Lanzamos un hilo con CreateRemoteThread, dando como punto de entrada la direccion de LoadLibrary
	Local $sRemoteThread = DllCall('Kernel32.dll', 'Bool', 'CreateRemoteThread', 'int', $sOpen[0], 'ptr', 0, 'ULONG_PTR', 0, 'ptr', $sGetProcAdress[0], 'ptr', $sMemory[0], 'dword', 0, 'dword', 0)
	;depuramos para saber si existe algun error
	If Not ($sRemoteThread[0]) Then
		MsgBox(64, '', 'Hubo un error lanzando el hilo')
	EndIf

	;Esperamos hasta que el objeto este seÃ±alado (0x7FFFFFFF = INFINITE)
	Local $sWait = DllCall('Kernel32.dll', 'ptr', 'WaitForSingleObject', 'handle', $sRemoteThread[0], 'dword', 0x7FFFFFFF)

	;Una vez terminada la inyeccion cerramos los handles abiertos
	Local $sClose1 = DllCall('Kernel32.dll', 'int', 'CloseHandle', 'handle', $sOpen[0])
	Local $sClose2 = DllCall('Kernel32.dll', 'int', 'CloseHandle', 'handle', $sMemory[0])
	;Volbemos a depurar
	If Not ($sClose1[0]) And ($sClose2[0]) Then
		MsgBox(64, '', 'Error cerrando los handles')
	EndIf

	If $sRemoteThread[0] = False Then
		MsgBox(64, '', 'Error Injectando la DLL')
	Else
		MsgBox(64, '', 'DLL Injectada con exito')
	EndIf
EndFunc   ;==>InjectDLL
